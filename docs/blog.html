<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.330">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>shannonrumsey - Deep Dives</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./cv.html" rel="" target="">
 <span class="menu-text">CV</span></a>
  </li>  
  <li class="dropdown-header">
 <span class="menu-text">CV</span></li>
  <li class="nav-item">
    <a class="nav-link active" href="./blog.html" rel="" target="" aria-current="page">
 <span class="menu-text">Deep Dives</span></a>
  </li>  
  <li class="dropdown-header">
 <span class="menu-text">Deep Dives</span></li>
  <li class="nav-item">
    <a class="nav-link" href="./Resume.pdf" rel="" target="">
 <span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/shannonrumsey" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/shannon-rumsey/" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="./shannonalmyrumsey@gmail.com" rel="" target=""><i class="bi bi-envelope" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#gpt-architecture" id="toc-gpt-architecture" class="nav-link active" data-scroll-target="#gpt-architecture">GPT Architecture</a>
  <ul class="collapse">
  <li><a href="#analogy" id="toc-analogy" class="nav-link" data-scroll-target="#analogy">Analogy</a></li>
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#step-1-encoding" id="toc-step-1-encoding" class="nav-link" data-scroll-target="#step-1-encoding">Step 1: Encoding</a></li>
  <li><a href="#step-2-token-embedding-optimize-storing-word-informationmeaning" id="toc-step-2-token-embedding-optimize-storing-word-informationmeaning" class="nav-link" data-scroll-target="#step-2-token-embedding-optimize-storing-word-informationmeaning">Step 2: Token Embedding: Optimize Storing Word Information/Meaning</a></li>
  <li><a href="#step-3-positional-encodings" id="toc-step-3-positional-encodings" class="nav-link" data-scroll-target="#step-3-positional-encodings">Step 3: Positional Encodings</a></li>
  <li><a href="#step-4-attention-single-head" id="toc-step-4-attention-single-head" class="nav-link" data-scroll-target="#step-4-attention-single-head">Step 4: Attention (Single Head)</a></li>
  <li><a href="#step-5-multi-head-attention" id="toc-step-5-multi-head-attention" class="nav-link" data-scroll-target="#step-5-multi-head-attention">Step 5: Multi-head Attention</a></li>
  <li><a href="#step-6-feed-forward" id="toc-step-6-feed-forward" class="nav-link" data-scroll-target="#step-6-feed-forward">Step 6: Feed Forward</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Deep Dives</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="gpt-architecture" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="gpt-architecture">GPT Architecture</h2>
<section id="analogy" class="level3">
<h3 class="anchored" data-anchor-id="analogy">Analogy</h3>
<p>We want to teach a computer the English language (which consists of 50,257 words) so that it can communicate and aid in problem-solving. To begin, we translate each English word to the computer‚Äôs language equivalent (cat -&gt; [0, 0, 1]), but this is not very helpful because it‚Äôs impractical and can create meaningless sentences. It would be very difficult for a human to learn Spanish using only an English-to-Spanish translation book. Instead of a direct lookup, we can provide a description or set of ratings (an embedding) for each word. These descriptions/ratings are updated continuously as the computer understands more and more about the language.</p>
<p>Understanding words is not enough to grasp a language; the way they are ordered is also important. For example, ‚Äúthe cat chased the mouse‚Äù has a very different meaning from ‚Äúthe mouse chased the cat‚Äù. In addition to providing a rating scheme for each word, we also include its position within the sentence.</p>
<p>In order for the computer to understand the language and communicate, it must be able to determine which words are important and how they relate to other words in the sentence. For example, in the sentence ‚Äúwhen she went to the bank, she saw a man,‚Äù the computer must be able to differentiate a financial institution from the side of a river, must reason that the two instances of ‚Äúshe‚Äù refer to the same person, and that the man was seen at the bank, not somewhere else.</p>
</section>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<ul>
<li>GPT models take a sentence in and predict the next word (only produces one word/token at a time through the entire transformer!).
<ul>
<li>They do this by assigning probabilities to words it may be, and selecting the word with the highest probability.</li>
<li>The input length will always be a certain number of words (e.g., GPT-3‚Äôs is 2048 words).
<ul>
<li>You can have a smaller input length; there will just be padding (empty values).</li>
<li>You cannot have a larger input length.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="step-1-encoding" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="step-1-encoding">Step 1: Encoding</h3>

<div class="no-row-height column-margin column-container"><div class="">
<p>üí° Turn words into vectors</p>
</div></div><ul>
<li>There is a dictionary of all words. Each word is associated with a numeric value (e.g., GPT-2 has a vocab size of 50,257 words).
<ul>
<li>Cat = 1, Dog = 2, Car = 3, etc.</li>
</ul></li>
<li>For each word, we map them to the corresponding location in the vocab dictionary, turning them into a one-hot encoding vector of size 50,257.
<ul>
<li>Cat would have the vector: [1, 0, 0, ‚Ä¶, 0].</li>
<li>Dog would have: [0, 1, 0, ‚Ä¶, 0].</li>
<li>Car would have: [0, 0, 1, ‚Ä¶, 0].</li>
</ul></li>
<li>Putting these vectors together in a matrix, we end up with 2048 rows, representing the number of words/tokens in the input sequence, and 50,257 columns, representing the number of words in the dictionary. The row corresponds with the location in the sequence and the column represents the location in the dictionary.
<ul>
<li>The matrix is 2048 x 50,257 and is made up of only 0s and 1s.</li>
</ul></li>
</ul>
</section>
<section id="step-2-token-embedding-optimize-storing-word-informationmeaning" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="step-2-token-embedding-optimize-storing-word-informationmeaning">Step 2: Token Embedding: Optimize Storing Word Information/Meaning</h3>

<div class="no-row-height column-margin column-container"><div class="">
<p>üí° Having so many empty (zeroes) slots in the matrix takes up too much unnecessary space</p>
</div></div><ul>
<li>Preserve semantic meaning of words in an optimal way using embedding functions.
<ul>
<li>We want to project this large one-hot encoded matrix to a smaller, dense vector space.
<ul>
<li>We initialize an embedding matrix with dimensions [vocab_size, embedding_dim].
<ul>
<li>Vocab size is 50,257 and embedding dim is the desired number of traits we want.</li>
</ul></li>
<li>Each one-hot vector in the matrix is mapped to this dense embedding vector (via multiplication).
<ul>
<li>This is called the embedding function.</li>
<li>This results in an embedding vector of size [1, embedding_dim] for each word in the dictionary.</li>
</ul></li>
<li>Each element in the embedding represents a learned trait of the word.
<ul>
<li>i.e., Dog may have the vector embedding [energetic = 10, cute = 10], whereas car has [energetic = 8, cute = 0].</li>
<li>This is a better way of storing the data because it provides more semantic information and is in a lower dimension.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="step-3-positional-encodings" class="level3">
<h3 class="anchored" data-anchor-id="step-3-positional-encodings">Step 3: Positional Encodings</h3>
<ul>
<li>We need to take into account the syntax of the input sentence, which can affect the meaning of a sentence.
<ul>
<li>For example, ‚Äúthe tea is too hot, I am turning red‚Äù is different from ‚Äúthe tea is turning red, I am too hot.‚Äù</li>
</ul></li>
<li>We have two options for learning position embeddings:
<ul>
<li>Encode the position of the current token using sinusoidal functions with differing frequencies (Used in <em>Attention is All You Need</em>).
<ul>
<li>These are absolute/universal embeddings.
<ul>
<li>Each position is represented with a fixed vector that is consistent across different sequences/sentences.
<ul>
<li>The vector for the 5th position in one sentence is the same in all other sentences.</li>
</ul></li>
</ul></li>
<li>We can represent the location number of a word in binary form, but it is more space-efficient to represent them using sinusoidal functions.</li>
<li>The frequency of the wave is tied to which bits we are representing.
<ul>
<li>A higher frequency allows us to represent the numbers 0-3. A lower frequency allows us to represent the numbers 4-15.</li>
<li>We are able to do this because the lowest bit alternates on every number, the second on every two numbers, etc. We line up the length of the sine/cosine wave‚Äôs cycle with the bits we want to represent.</li>
</ul></li>
</ul></li>
<li>Trained/Learned Positional Embeddings (Used in GPT-2).
<ul>
<li>Relative positions of words.
<ul>
<li>The position of words in a given sentence; not universal across all sentences.</li>
</ul></li>
<li>Initialize a matrix with dimensions [max_positions, embedding_dim].
<ul>
<li>What the matrix is filled with at initialization can vary. PyTorch‚Äôs ‚Äúnn.Embedding‚Äù will randomly sample values from a standard normal distribution.</li>
<li>Max_positions is the maximum sequence length that the model can expect (2048 words).</li>
<li>Embedding_dim must be the same number used for the token embeddings because they will be summed together to form the official input of the model.</li>
</ul></li>
<li>During training, the position in the input sequence is mapped to its corresponding row in the matrix.
<ul>
<li>The second position in a sequence is the second row in the matrix.</li>
<li>Embeddings are learned during backpropagation and are adjusted to minimize the loss function.</li>
<li>In the forward pass, these learned positional embeddings are added to token embeddings.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="step-4-attention-single-head" class="level3">
<h3 class="anchored" data-anchor-id="step-4-attention-single-head">Step 4: Attention (Single Head)</h3>
<ul>
<li>Determine how important each input token is in predicting the output.</li>
<li>Each attention head processes a single sequence at a time.</li>
<li>For each head, compute three linear projections to result in a query, key, and value projection. The resulting dimensions for each matrix are [batch size, sequence length, number of embeddings / number of heads].
<ul>
<li>Linear projection: y = Wx + b.
<ul>
<li>y is the resulting projection (query, key, and value).</li>
<li>W is the matrix of weights.
<ul>
<li>The first weights matrix is query, the second for key, and the third for value.</li>
</ul></li>
<li>x is the input.
<ul>
<li>This is the summed positional embeddings and token embeddings.</li>
</ul></li>
<li>b is the bias.</li>
</ul></li>
<li>Queries are the task/meaning of interest.</li>
<li>Keys find relevant information based on the task.</li>
<li>Values are the actual information from the tokens.</li>
</ul></li>
<li>The linear projection/transformation gives us 3 new projection matrices: queries, keys, and values.
<ul>
<li>The query and key (transposed) matrices are multiplied together and normalized through softmax (this turns raw scores into attention weights).
<ul>
<li>Determines tokens most relevant to queries.</li>
<li>For example, in ‚Äúthe cat that chased the dog was tired,‚Äù ‚Äúthe cat‚Äù and ‚Äúwas tired‚Äù are related despite there being words in between.</li>
</ul></li>
<li>This new matrix is multiplied by the values matrix.
<ul>
<li>Provides information about tokens of interest.</li>
<li>The final resulting matrix is [batch size, sequence length, number of embeddings].</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="step-5-multi-head-attention" class="level3">
<h3 class="anchored" data-anchor-id="step-5-multi-head-attention">Step 5: Multi-head Attention</h3>
<ul>
<li>The process in step 4 is repeated multiple times (because of multiple heads).</li>
<li>The results from each attention head are concatenated together.</li>
<li>A final linear transformation is applied to project the outputs back to the original embedding dimension.
<ul>
<li>This is important because it‚Äôs the dimensions ([batch size, sequence length, embedding dimensions]) that the layers expect as input.</li>
</ul></li>
</ul>
</section>
<section id="step-6-feed-forward" class="level3">
<h3 class="anchored" data-anchor-id="step-6-feed-forward">Step 6: Feed Forward</h3>
<section id="an-implementation-following-this-tutorial-can-be-found-here" class="level4">
<h4 class="anchored" data-anchor-id="an-implementation-following-this-tutorial-can-be-found-here">An implementation following <a href="https://www.youtube.com/watch?v=l8pRSuU81PU&amp;t=4895s">this tutorial</a> can be found <a href="https://github.com/shannonrumsey/medGPT">here</a></h4>
</section>
<section id="references" class="level4">
<h4 class="anchored" data-anchor-id="references">References</h4>
<p><a href="https://dugas.ch/artificial_curiosity/GPT_architecture.html">The GPT-3 Architecture, on a Napkin</a></p>
<p><a href="https://kazemnejad.com/blog/transformer_architecture_positional_encoding/">Transformer Architecture: The Positional Encoding</a></p>
<p><a href="https://medium.com/mantisnlp/positional-encodings-i-main-approaches-bd1199d6770d">Positional Encodings: Main Approaches</a></p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/shannonrumsey">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/shannon-rumsey/">
      <i class="bi bi-linkedin" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="mailto::shannonalmyrumsey@gmail.com">
      <i class="bi bi-envelope" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>



</body></html>